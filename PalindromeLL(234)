// Leetcode 234... Palindrome linked list
Brute force approach
1. Create a Stack data structure
2. Create a node temp and place it at the head of LL
3. Push the data element of temp to the stack and update temp until it reaches null
4. Assign head to the temp node
5. Check if temp.data is equal to stack's topmost element
6. Return false if it is not equal, update temp and move to next element in stack until stack is empty
7. Finally return true if all elements are equal
class Solution {
    public boolean isPalindrome(ListNode head) {
        Stack<Integer> stk = new Stack<>();
        ListNode temp=head;
        while(temp!=null){
            stk.push(temp.val);
            temp = temp.next;
        }
        temp=head;
        while(temp!=null){
            if(temp.val!=stk.peek()){
                return false;
            }
            temp = temp.next;
            stk.pop();
        }
        return true;
    }
} 

// Optimal solution
1. Find the middle of the linked list
2. Reverse the second half
3. Compare first half's first value and second half's first value, do this till second not equal null
4. If there is no not equal values then returns true
class Solution {
    public ListNode reverse(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
        ListNode newHead = reverse(head.next);
        head.next.next = head;
        head.next = null;
        return newHead;
    }
    public boolean isPalindrome(ListNode head) {
        ListNode slow = head, fast = head;
        boolean palindrome = true;
        while(fast.next!=null && fast.next.next!=null){
              slow = slow.next;
              fast = fast.next.next;
        }
        ListNode newHead = reverse(slow.next);
        ListNode first = head;
        ListNode second = newHead;
        while(second!=null){
            if(first.val != second.val){
                reverse(newHead);
                return false;
            }
            first = first.next;
            second = second.next;

        }
        reverse(newHead);
        return true;
    }
}
